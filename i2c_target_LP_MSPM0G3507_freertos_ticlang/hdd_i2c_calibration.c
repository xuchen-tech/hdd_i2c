#include <ti/driverlib/dl_flashctl.h>

#include "hdd_i2c_calibraton.h"

/* 8-bit data to write to flash */
uint8_t gData8 = 0x11;

/* 16-bit data to write to flash */
uint16_t gData16 = 0x2222;

/* 32-bit data to write to flash */
uint32_t gData32 = 0x33333333;

/* Array to write 64-bits to flash */
uint32_t gDataArray64[] = {0xABCDEF00, 0x12345678};

volatile DL_FLASHCTL_COMMAND_STATUS gCmdStatus;

/* Codes to understand where error occured */
#define NO_ERROR 0
#define ERROR_ERASE 1
#define ERROR_WRITE_8_BIT 2
#define ERROR_READ_8_BIT 3
#define ERROR_WRITE_16_BIT 4
#define ERROR_READ_16_BIT 5
#define ERROR_WRITE_32_BIT 6
#define ERROR_READ_32_BIT 7
#define ERROR_WRITE_64_BIT 8
#define ERROR_READ_64_BIT 9
#define ERROR_EXPECTED_FAIL 10
#define ERROR_UNEXPECTED 11
#define ERROR_WRITE_64_OVERRIDE 12
#define ERROR_READ_64_OVERRIDE 13
#define ERROR_EXPECTED_FAIL_OVERRIDE 14
#define ERROR_8BIT_W 2
#define ERROR_16BIT_W 3
#define ERROR_32BIT_W 4
#define ERROR_64BIT_W 5

volatile uint8_t gErrorType = NO_ERROR;

bool hddI2CCalibrationInit(void) {
  /* Unprotect sector in main memory with ECC generated by hardware */
  DL_FlashCTL_unprotectSector(FLASHCTL, MAIN_BASE_ADDRESS,
                              DL_FLASHCTL_REGION_SELECT_MAIN);
  /* Erase sector in main memory */
  gCmdStatus = DL_FlashCTL_eraseMemoryFromRAM(FLASHCTL, MAIN_BASE_ADDRESS,
                                              DL_FLASHCTL_COMMAND_SIZE_SECTOR);
  if (gCmdStatus == DL_FLASHCTL_COMMAND_STATUS_FAILED) {
    /* If command was not successful, set error flag */
    SEGGER_RTT_printf(0, "Flash erase failed during calibration init\n");
    gErrorType = ERROR_ERASE;
  } else {
    SEGGER_RTT_printf(0, "Flash erase succeeded during calibration init\n");
  }

  if (gErrorType == NO_ERROR) {
    /* 8-bit write to flash in main memory */
    DL_FlashCTL_unprotectSector(FLASHCTL, MAIN_BASE_ADDRESS,
                                DL_FLASHCTL_REGION_SELECT_MAIN);
    gCmdStatus = DL_FlashCTL_programMemoryFromRAM8WithECCGenerated(
        FLASHCTL, MAIN_BASE_ADDRESS, &gData8);
    if (gCmdStatus == DL_FLASHCTL_COMMAND_STATUS_FAILED) {
      /* If command was not successful, set error flag */
      SEGGER_RTT_printf(0, "Flash 8-bit write failed during calibration init\n");
      gErrorType = ERROR_8BIT_W;
    } else {
      SEGGER_RTT_printf(0, "Flash 8-bit write succeeded during calibration init\n");
    }

    if (gErrorType == NO_ERROR) {
        /* Read verify on the 8-bit data */
        gCmdStatus = DL_FlashCTL_readVerifyFromRAM8WithECCGenerated(
            FLASHCTL, MAIN_BASE_ADDRESS, &gData8);
        if (gCmdStatus != DL_FLASHCTL_COMMAND_STATUS_PASSED) {
            /* If command did not pass, set error flag. */
            gErrorType = ERROR_READ_8_BIT;
        } else {
            SEGGER_RTT_printf(0, "Flash 8-bit read verify passed during calibration init: value:%d\n", gData8);
        }
    }
  }

  if (gErrorType == NO_ERROR) {
    /*
     * 16-bit write to flash in main memory with ECC generated by hardware.
     * The target program address must be a flash word address
     * (8-byte aligned), so we increase the address in increments of 8.
     */
    DL_FlashCTL_unprotectSector(FLASHCTL, MAIN_BASE_ADDRESS,
                                DL_FLASHCTL_REGION_SELECT_MAIN);
    gCmdStatus = DL_FlashCTL_programMemoryFromRAM16WithECCGenerated(
        FLASHCTL, (MAIN_BASE_ADDRESS + 8), &gData16);
    if (gCmdStatus == DL_FLASHCTL_COMMAND_STATUS_FAILED) {
      /* If command was not successful, set error flag */
      SEGGER_RTT_printf(0, "Flash 16-bit write failed during calibration init\n");
      gErrorType = ERROR_16BIT_W;
    } else {
      SEGGER_RTT_printf(0, "Flash 16-bit write succeeded during calibration init\n");
    }
  }

  if (gErrorType == NO_ERROR) {
    /* 32-bit write to flash in main memory with ECC generated by hardware */
    DL_FlashCTL_unprotectSector(FLASHCTL, MAIN_BASE_ADDRESS,
                                DL_FLASHCTL_REGION_SELECT_MAIN);
    gCmdStatus = DL_FlashCTL_programMemoryFromRAM32WithECCGenerated(
        FLASHCTL, (MAIN_BASE_ADDRESS + 16), &gData32);
    if (gCmdStatus == DL_FLASHCTL_COMMAND_STATUS_FAILED) {
      /* If command was not successful, set error flag */
        SEGGER_RTT_printf(0, "Flash 32-bit write failed during calibration init\n");
      gErrorType = ERROR_32BIT_W;
    } else {
      SEGGER_RTT_printf(0, "Flash 32-bit write succeeded during calibration init\n");
    }
  }

  if (gErrorType == NO_ERROR) {
    /*
     * 64-bit write to flash in main memory with ECC generated by hardware.
     * Data must be loaded 32-bits at a time, but a single word program
     * is executed
     */
    DL_FlashCTL_unprotectSector(FLASHCTL, MAIN_BASE_ADDRESS,
                                DL_FLASHCTL_REGION_SELECT_MAIN);
    gCmdStatus = DL_FlashCTL_programMemoryFromRAM64WithECCGenerated(
        FLASHCTL, (MAIN_BASE_ADDRESS + 24), &gDataArray64[0]);
    if (gCmdStatus == DL_FLASHCTL_COMMAND_STATUS_FAILED) {
        SEGGER_RTT_printf(0, "Flash 64-bit write failed during calibration init\n");
      /* If command was not successful, set error flag */
      gErrorType = ERROR_64BIT_W;
    } else {
      SEGGER_RTT_printf(0, "Flash 64-bit write succeeded during calibration init\n");
    }
  }
}